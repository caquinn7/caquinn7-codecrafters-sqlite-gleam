The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes.
-------------

B-tree Page Header Format
-------------------------
Offset	Size	Description
-------------------------
0	    1	The one-byte flag at offset 0 indicating the b-tree page type.
            A value of 2 (0x02) means the page is an interior index b-tree page.
            A value of 5 (0x05) means the page is an interior table b-tree page.
            A value of 10 (0x0a) means the page is a leaf index b-tree page.
            A value of 13 (0x0d) means the page is a leaf table b-tree page.
            Any other value for the b-tree page type is an error.
1	    2	The two-byte integer at offset 1 gives the start of the first freeblock on the page,
            or is zero if there are no freeblocks.
3	    2	The two-byte integer at offset 3 gives the number of cells on the page.
5	    2	The two-byte integer at offset 5 designates the start of the cell content area.
            A zero value for this integer is interpreted as 65536.
7	    1	The one-byte integer at offset 7 gives the number of fragmented free bytes
            within the cell content area.
8	    4	The four-byte page number at offset 8 is the right-most pointer.
            This value appears in the header of interior b-tree pages only
            and is omitted from all other pages.
            (The child page number for the rightmost child page.)

The cell pointer array of a b-tree page immediately follows the b-tree page header.
Let K be the number of cells on the btree. The cell pointer array consists of K 2-byte integer offsets to the cell contents.
The cell pointers are arranged in key order with left-most cell (the cell with the smallest key) first
and the right-most cell (the cell with the largest key) last.

---------------------------------------------------------

Table Leaf Cell (header 0x0d):
* A varint which is the total number of bytes of payload, including any overflow
* A varint which is the integer key, a.k.a. "rowid"
* The initial portion of the payload that does not spill to overflow pages.
* A 4-byte big-endian integer page number for the first page of the overflow page list -
    omitted if all payload fits on the b-tree page.

Table Interior Cell (header 0x05):
* A 4-byte big-endian page number which is the left child pointer.
* A varint which is the integer key

Index Leaf Cell (header 0x0a):
* A varint which is the total number of bytes of key payload, including any overflow
* The initial portion of the payload that does not spill to overflow pages.
* A 4-byte big-endian integer page number for the first page of the overflow page list -
    omitted if all payload fits on the b-tree page.

Index Interior Cell (header 0x02):
* A 4-byte big-endian page number which is the left child pointer.
* A varint which is the total number of bytes of key payload, including any overflow
* The initial portion of the payload that does not spill to overflow pages.
* A 4-byte big-endian integer page number for the first page of the overflow page list -
    omitted if all payload fits on the b-tree page.

---------------------------------------------------------
interior_schema.db

00000064  05 00 00 00 02 0f ea 00  00 00 00 4a  0f ef  0f ea

2 cells
cell content offset 0f ea
rightmost page 74

0f ef => 00 00 00 25  22 (page 37 key 34)
0f ea => 00 00 00 27  42 (page 39 key 66)

page 37 (37 * 4096 = 151552)
00025000  0d 00 00 00 00 0f f4 00

page 39 (159744)
00027000  0d 00 00 00 00 0f f4 00

page 74
0004a000  0d 00 00 00 00 0f f4 00

---------------------------------------------------------
Decoding Leaf Cells

Table B-Tree Leaf Cell
0f 01 05 00 15 13 03 4a 6f 68 6e 44 6f 65 00 ea 60

0f: payload size 15 bytes
01: rowid
05 00 15 13 03:
    05: header size 5 bytes
    00: ?
    15: 0x15 = 21 => (21 - 13) / 2 = 4 => 4 character string
    13: 0x13 = 19 => (19 - 13) / 2 = 3 => 3 character string
    03: 3-byte two's complement integer
4a 6f 68 6e: John
44 6f 65: Doe
00 ea 60: 60000


Index B-Tree Leaf Cell
0c 03 1d 01 4d 61 72 74 69 6e 65 7a 0a 

0c: payload size 12 bytes
03 1d 01:
    03: header size 3 bytes
    1d: 0x1d = 29 => (29 - 13) / 2 = 8 => 8 character string
    01: 1-byte two's complement integer
4d 61 72 74 69 6e 65 7a: Martinez
0a: 10 (the rowid)

---------------------------------------------------------
Serial Type Codes Of The Record Format
Serial Type	    Content Size	Meaning
0	            0	    Value is a NULL.
1	            1	    Value is an 8-bit twos-complement integer.
2	            2	    Value is a big-endian 16-bit twos-complement integer.
3	            3	    Value is a big-endian 24-bit twos-complement integer.
4	            4	    Value is a big-endian 32-bit twos-complement integer.
5	            6	    Value is a big-endian 48-bit twos-complement integer.
6	            8	    Value is a big-endian 64-bit twos-complement integer.
7	            8	    Value is a big-endian IEEE 754-2008 64-bit floating point number.
8	            0	    Value is the integer 0. (Only available for schema format 4 and higher.)
9	            0	    Value is the integer 1. (Only available for schema format 4 and higher.)
10,11	        variable	Reserved for internal use. These serial type codes will never appear in a well-formed database file, but they might be used in transient and temporary database files that SQLite sometimes generates for its own use. The meanings of these codes can shift from one release of SQLite to the next.
N≥12 and even	(N-12)/2	Value is a BLOB that is (N-12)/2 bytes in length.
N≥13 and odd	(N-13)/2	Value is a string in the text encoding and (N-13)/2 bytes in length. The nul terminator is not stored.


is_manager = 0
10 01 06 00 15 13 03 08 4a 6f 68 6e 44 6f 65 00 ea 60
06 00 15 13 03 08

is_manager = 1
12 02 06 00 15 17 03 09 4a 61 6e 65 53 6d 69 74 68 00 fd e8
06 00 15 17 03 09




  // [
  //   TableRecord(1, [
  //     Some(Text("table")),
  //     Some(Text("employees")),
  //     Some(Text("employees")),
  //     Some(Integer(2)),
  //     Some(Text(
  //       "CREATE TABLE employees (\n    id INTEGER PRIMARY KEY,\n    first_name TEXT,\n    last_name TEXT,\n    salary INTEGER\n)",
  //     )),
  //   ]),
  //   TableRecord(2, [
  //     Some(Text("index")),
  //     Some(Text("idx_last_name")),
  //     Some(Text("employees")),
  //     Some(Integer(3)),
  //     Some(Text("CREATE INDEX idx_last_name ON employees(last_name)")),
  //   ]),
  // ]